<html>
	<head>
	</head>
	<body>
		<script type="module">
			async function init() {
				const adapter = await navigator.gpu.requestAdapter();
				if (!adapter) {
					console.log("Error, webgpu is not supported");
					return;
				}

				const device = await adapter.requestDevice();
				console.log("Got a device", device);

				return device;
			}

			async function relu() {
				const device = await init();
				const elements = [-1.0, 2.0, -3.0, 4.0, -0.5, 0.0];

				const input = device.createBuffer({
					size: elements.length * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});
				device.queue.writeBuffer(input, 0, new Float32Array(elements));

				const shader =`
					@group(0) @binding(0) var<storage, read_write> data : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						data[id.x] = max(data[id.x], 0.0);
					}
				`

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: {buffer: input}
						},
					]
				});

				const stagingBuffer = device.createBuffer({
					size: elements.length * 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(elements.length);
				pass.end();

				encoder.copyBufferToBuffer(input, 0, stagingBuffer, 0, elements.length * 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const output = new Float32Array(stagingBuffer.getMappedRange());
				console.log(output);
				stagingBuffer.unmap();
			}

			async function matmul() {
				const M = 2;
				const K = 3;
				const N = 2;

				const device = await init();

				const matrixA = device.createBuffer({
					size: M * K * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const matrixB = device.createBuffer({
					size: N * K * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const result = device.createBuffer({
					size: M * N * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});

				const dimensions = device.createBuffer({
					size: 4 * 4, // (M, N, K) - minimum binding size for uniform buffers must be a multiple of 16.
					usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})
				const shader = `
					struct Dimensions { M: u32, N: u32, K: u32 }
					@group(0) @binding(0) var<uniform> dims : Dimensions;
					@group(0) @binding(1) var<storage, read> input_a : array<f32>;
					@group(0) @binding(2) var<storage, read> input_b : array<f32>;
					@group(0) @binding(3) var<storage, read_write> output : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						var sum: f32 = 0.0;
						var col: u32 = id.x;
						var row: u32 = id.y;
						for (var i: u32 = 0u; i < dims.K; i = i + 1u) {
							sum += input_a[row * dims.K + i] * input_b[i * dims.N + col];
						}
						output[row * dims.N + col] = sum;
					}
				`;

				device.queue.writeBuffer(matrixA, 0, new Float32Array([1,2,3,4,5,6]));
				device.queue.writeBuffer(matrixB, 0, new Float32Array([7,8,9,10,11,12]));
				device.queue.writeBuffer(dimensions, 0, new Uint32Array([2,2,3]));

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: {buffer: dimensions}
						},
						{
							binding: 1,
							resource: { buffer: matrixA }
						},
						{
							binding: 2,
							resource: { buffer: matrixB }
						},
						{
							binding: 3,
							resource: { buffer: result }
						}
					]
				});

				const stagingBuffer = device.createBuffer({
					size: M * N * 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(N, M);
				pass.end();

				encoder.copyBufferToBuffer(result, 0, stagingBuffer, 0, M * N * 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const output = new Float32Array(stagingBuffer.getMappedRange());
				console.log(output);
				stagingBuffer.unmap();
			}

			async function sum() {
				const device = await init();
				const shader = `
					@group(0) @binding(0) var<storage, read> input_a : array<f32>;
					@group(0) @binding(1) var<storage, read> input_b : array<f32>;
					@group(0) @binding(2) var<storage, read_write> output : array<f32>;
					@compute @workgroup_size(1)
					fn main() {
						output[0] = input_a[0] + input_b[0];
					}
				`;

				const bufferA = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const bufferB = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const output = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});

				device.queue.writeBuffer(bufferA, 0, new Float32Array([3.0]));
			    device.queue.writeBuffer(bufferB, 0, new Float32Array([4.0]));

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: { buffer: bufferA }
						},
						{
							binding: 1,
							resource: { buffer: bufferB }
						},
						{
							binding: 2,
							resource: { buffer: output }
						}
					]
				});

				const stagingBuffer = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(1);
				pass.end();

				encoder.copyBufferToBuffer(output, 0, stagingBuffer, 0, 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const result = new Float32Array(stagingBuffer.getMappedRange());
				console.log(result);
				stagingBuffer.unmap();
			}
			relu();
		</script>
	</body>
</html>
