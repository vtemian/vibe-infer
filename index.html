<html>
	<head>
		<style>
			body {
				font-family: system-ui, sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				background: #1a1a2e;
				color: #e0e0e0;
				margin: 0;
				padding: 20px;
			}
			h1 { color: #fff; margin-bottom: 4px; }
			.subtitle { color: #888; margin-bottom: 24px; font-size: 14px; }
			.container {
				display: flex;
				gap: 40px;
				align-items: flex-start;
			}
			canvas#draw {
				border: 2px solid #444;
				border-radius: 8px;
				cursor: crosshair;
				background: #000;
			}
			canvas#preview {
				border: 1px solid #333;
				border-radius: 4px;
				image-rendering: pixelated;
			}
			.right-panel {
				display: flex;
				flex-direction: column;
				gap: 16px;
			}
			.prediction {
				font-size: 72px;
				font-weight: bold;
				text-align: center;
				color: #4fc3f7;
				min-height: 90px;
			}
			.confidence {
				text-align: center;
				color: #888;
				font-size: 14px;
			}
			.bars {
				display: flex;
				flex-direction: column;
				gap: 4px;
				width: 260px;
			}
			.bar-row {
				display: flex;
				align-items: center;
				gap: 8px;
				font-size: 13px;
			}
			.bar-label { width: 12px; text-align: right; color: #aaa; }
			.bar-track {
				flex: 1;
				height: 16px;
				background: #2a2a3e;
				border-radius: 3px;
				overflow: hidden;
			}
			.bar-fill {
				height: 100%;
				background: #4fc3f7;
				border-radius: 3px;
				transition: width 0.15s;
			}
			.bar-fill.top { background: #4fc3f7; }
			.bar-value { width: 40px; font-size: 11px; color: #666; }
			button {
				padding: 8px 20px;
				border: 1px solid #444;
				border-radius: 6px;
				background: #2a2a3e;
				color: #e0e0e0;
				cursor: pointer;
				font-size: 14px;
			}
			button:hover { background: #3a3a4e; }
			.status { color: #666; font-size: 12px; text-align: center; }
		</style>
	</head>
	<body>
		<h1>GPU Inference from Scratch</h1>
		<p class="subtitle">Draw a digit. WebGPU classifies it. No frameworks.</p>
		<div class="container">
			<div>
				<canvas id="draw" width="280" height="280"></canvas>
				<div style="display: flex; gap: 8px; margin-top: 8px; justify-content: center;">
					<button id="clear">Clear</button>
					<canvas id="preview" width="56" height="56"></canvas>
				</div>
			</div>
			<div class="right-panel">
				<div class="prediction" id="digit">-</div>
				<div class="confidence" id="conf"></div>
				<div class="bars" id="bars"></div>
			</div>
		</div>
		<p class="status" id="status">Loading model...</p>

		<script type="module">
			// --- GPU setup ---
			async function init() {
				const adapter = await navigator.gpu.requestAdapter();
				if (!adapter) {
					document.getElementById('status').textContent = 'WebGPU not supported';
					return;
				}
				return await adapter.requestDevice();
			}

			function createBuffer(device, data, usage) {
				const buffer = device.createBuffer({
					size: data.byteLength,
					usage: usage,
					mappedAtCreation: false
				});
				device.queue.writeBuffer(buffer, 0, data);
				return buffer;
			}

			function createPipeline(device, shaderCode) {
				const module = device.createShaderModule({ code: shaderCode });
				return device.createComputePipeline({
					layout: 'auto',
					compute: { module: module, entryPoint: 'main' }
				});
			}

			async function readBackBuffer(device, srcBuffer, size) {
				const staging = device.createBuffer({
					size: size,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});
				const encoder = device.createCommandEncoder();
				encoder.copyBufferToBuffer(srcBuffer, 0, staging, 0, size);
				device.queue.submit([encoder.finish()]);
				await staging.mapAsync(GPUMapMode.READ);
				const result = new Float32Array(staging.getMappedRange().slice(0));
				staging.unmap();
				return result;
			}

			// --- Shaders ---
			const MAT_MUL_SHADER = `
				struct Dimensions { M: u32, N: u32, K: u32 }
				@group(0) @binding(0) var<uniform> dims : Dimensions;
				@group(0) @binding(1) var<storage, read> input_a : array<f32>;
				@group(0) @binding(2) var<storage, read> input_b : array<f32>;
				@group(0) @binding(3) var<storage, read> bias : array<f32>;
				@group(0) @binding(4) var<storage, read_write> output : array<f32>;
				@compute @workgroup_size(1)
				fn main(@builtin(global_invocation_id) id : vec3<u32>) {
					var sum: f32 = 0.0;
					var col: u32 = id.x;
					var row: u32 = id.y;
					for (var i: u32 = 0u; i < dims.K; i = i + 1u) {
						sum += input_a[row * dims.K + i] * input_b[i * dims.N + col];
					}
					output[row * dims.N + col] = sum + bias[col];
				}
			`;

			const RELU_SHADER = `
				@group(0) @binding(0) var<storage, read_write> data : array<f32>;
				@compute @workgroup_size(1)
				fn main(@builtin(global_invocation_id) id : vec3<u32>) {
					data[id.x] = max(data[id.x], 0.0);
				}
			`;

			const SOFTMAX_SHADER = `
				@group(0) @binding(0) var<storage, read_write> data : array<f32>;
				@compute @workgroup_size(1)
				fn main(@builtin(global_invocation_id) id : vec3<u32>) {
					var max_val: f32 = data[0];
					var sum: f32 = 0.0;
					for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
						max_val = max(max_val, data[i]);
					}
					for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
						data[i] = exp(data[i] - max_val);
						sum += data[i];
					}
					for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
						data[i] = data[i] / sum;
					}
				}
			`;

			// --- Model setup (once) ---
			async function loadModel() {
				const device = await init();
				if (!device) return null;

				const w1 = new Float32Array(await (await fetch('weights/w1.bin')).arrayBuffer());
				const w2 = new Float32Array(await (await fetch('weights/w2.bin')).arrayBuffer());
				const b1 = new Float32Array(await (await fetch('weights/b1.bin')).arrayBuffer());
				const b2 = new Float32Array(await (await fetch('weights/b2.bin')).arrayBuffer());

				const W1 = createBuffer(device, w1, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
				const bias1 = createBuffer(device, b1, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
				const W2 = createBuffer(device, w2, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
				const bias2 = createBuffer(device, b2, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);

				const dims1 = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
				device.queue.writeBuffer(dims1, 0, new Uint32Array([1, 128, 784]));

				const dims2 = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
				device.queue.writeBuffer(dims2, 0, new Uint32Array([1, 10, 128]));

				const matmulPipeline = createPipeline(device, MAT_MUL_SHADER);
				const reluPipeline = createPipeline(device, RELU_SHADER);
				const softmaxPipeline = createPipeline(device, SOFTMAX_SHADER);

				return { device, W1, bias1, W2, bias2, dims1, dims2, matmulPipeline, reluPipeline, softmaxPipeline };
			}

			// --- Inference (per image) ---
			async function infer(model, imageData) {
				const { device, W1, bias1, W2, bias2, dims1, dims2, matmulPipeline, reluPipeline, softmaxPipeline } = model;

				const input = createBuffer(device, imageData, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
				const hidden = device.createBuffer({ size: 128 * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC });
				const output = device.createBuffer({ size: 10 * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC });

				const matmul1BG = device.createBindGroup({
					layout: matmulPipeline.getBindGroupLayout(0),
					entries: [
						{ binding: 0, resource: { buffer: dims1 } },
						{ binding: 1, resource: { buffer: input } },
						{ binding: 2, resource: { buffer: W1 } },
						{ binding: 3, resource: { buffer: bias1 } },
						{ binding: 4, resource: { buffer: hidden } },
					]
				});

				const reluBG = device.createBindGroup({
					layout: reluPipeline.getBindGroupLayout(0),
					entries: [{ binding: 0, resource: { buffer: hidden } }]
				});

				const matmul2BG = device.createBindGroup({
					layout: matmulPipeline.getBindGroupLayout(0),
					entries: [
						{ binding: 0, resource: { buffer: dims2 } },
						{ binding: 1, resource: { buffer: hidden } },
						{ binding: 2, resource: { buffer: W2 } },
						{ binding: 3, resource: { buffer: bias2 } },
						{ binding: 4, resource: { buffer: output } },
					]
				});

				const softmaxBG = device.createBindGroup({
					layout: softmaxPipeline.getBindGroupLayout(0),
					entries: [{ binding: 0, resource: { buffer: output } }]
				});

				const encoder = device.createCommandEncoder();

				const p1 = encoder.beginComputePass();
				p1.setPipeline(matmulPipeline);
				p1.setBindGroup(0, matmul1BG);
				p1.dispatchWorkgroups(128, 1);
				p1.end();

				const p2 = encoder.beginComputePass();
				p2.setPipeline(reluPipeline);
				p2.setBindGroup(0, reluBG);
				p2.dispatchWorkgroups(128);
				p2.end();

				const p3 = encoder.beginComputePass();
				p3.setPipeline(matmulPipeline);
				p3.setBindGroup(0, matmul2BG);
				p3.dispatchWorkgroups(10, 1);
				p3.end();

				const p4 = encoder.beginComputePass();
				p4.setPipeline(softmaxPipeline);
				p4.setBindGroup(0, softmaxBG);
				p4.dispatchWorkgroups(1);
				p4.end();

				device.queue.submit([encoder.finish()]);
				return await readBackBuffer(device, output, 10 * 4);
			}

			// --- Canvas drawing ---
			function setupCanvas() {
				const canvas = document.getElementById('draw');
				const ctx = canvas.getContext('2d');
				let drawing = false;

				ctx.lineWidth = 18;
				ctx.lineCap = 'round';
				ctx.lineJoin = 'round';
				ctx.strokeStyle = '#fff';

				canvas.addEventListener('mousedown', (e) => {
					drawing = true;
					ctx.beginPath();
					ctx.moveTo(e.offsetX, e.offsetY);
				});

				canvas.addEventListener('mousemove', (e) => {
					if (!drawing) return;
					ctx.lineTo(e.offsetX, e.offsetY);
					ctx.stroke();
				});

				canvas.addEventListener('mouseup', () => { drawing = false; });
				canvas.addEventListener('mouseleave', () => { drawing = false; });

				return { canvas, ctx };
			}

			function canvasToMNIST(canvas) {
				// Downscale 280x280 drawing to 28x28
				const small = document.createElement('canvas');
				small.width = 28;
				small.height = 28;
				const sctx = small.getContext('2d');
				sctx.drawImage(canvas, 0, 0, 28, 28);

				// Show preview
				const preview = document.getElementById('preview');
				const pctx = preview.getContext('2d');
				pctx.imageSmoothingEnabled = false;
				pctx.clearRect(0, 0, 56, 56);
				pctx.drawImage(small, 0, 0, 56, 56);

				// Extract grayscale, normalize with MNIST stats
				const pixels = sctx.getImageData(0, 0, 28, 28).data;
				const input = new Float32Array(784);
				for (let i = 0; i < 784; i++) {
					const gray = pixels[i * 4 + 3] / 255.0; // use alpha channel (white on black)
					input[i] = (gray - 0.1307) / 0.3081;    // MNIST normalization
				}
				return input;
			}

			function updateUI(probs) {
				const maxIdx = probs.indexOf(Math.max(...probs));
				document.getElementById('digit').textContent = maxIdx;
				document.getElementById('conf').textContent = (probs[maxIdx] * 100).toFixed(1) + '% confidence';

				const barsEl = document.getElementById('bars');
				barsEl.innerHTML = '';
				for (let i = 0; i < 10; i++) {
					const pct = (probs[i] * 100).toFixed(1);
					const row = document.createElement('div');
					row.className = 'bar-row';
					row.innerHTML = `
						<span class="bar-label">${i}</span>
						<div class="bar-track">
							<div class="bar-fill ${i === maxIdx ? 'top' : ''}" style="width: ${pct}%"></div>
						</div>
						<span class="bar-value">${pct}%</span>
					`;
					barsEl.appendChild(row);
				}
			}

			// --- Main ---
			async function main() {
				const model = await loadModel();
				if (!model) return;

				document.getElementById('status').textContent = 'Draw a digit (0-9)';

				const { canvas, ctx } = setupCanvas();
				let inferTimeout = null;

				function scheduleInfer() {
					clearTimeout(inferTimeout);
					inferTimeout = setTimeout(async () => {
						const input = canvasToMNIST(canvas);
						const probs = await infer(model, input);
						updateUI(Array.from(probs));
					}, 150);
				}

				canvas.addEventListener('mousemove', () => { if (canvas.matches(':active')) scheduleInfer(); });
				canvas.addEventListener('mouseup', scheduleInfer);

				document.getElementById('clear').addEventListener('click', () => {
					ctx.clearRect(0, 0, 280, 280);
					document.getElementById('digit').textContent = '-';
					document.getElementById('conf').textContent = '';
					document.getElementById('bars').innerHTML = '';
					const pctx = document.getElementById('preview').getContext('2d');
					pctx.clearRect(0, 0, 56, 56);
				});
			}

			main();
		</script>
	</body>
</html>
