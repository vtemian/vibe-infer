<html>
	<head>
	</head>
	<body>
		<script type="module">
			async function init() {
				const adapter = await navigator.gpu.requestAdapter();
				if (!adapter) {
					console.log("Error, webgpu is not supported");
					return;
				}

				const device = await adapter.requestDevice();
				console.log("Got a device", device);

				return device;
			}

			function createBuffer(device, data, usage) {
				const buffer = device.createBuffer({
					size: data.byteLength,
					usage: usage,
					mappedAtCreation: false
				});
				device.queue.writeBuffer(buffer, 0, data);
				return buffer;
			}

			function createPipeline(device, shaderCode) {
				const module = device.createShaderModule({ code: shaderCode });
				return device.createComputePipeline({
					layout: 'auto',
					compute: { module: module, entryPoint: 'main' }
				});
			}

			async function readBackBuffer(device, srcBuffer, size) {
				const staging = device.createBuffer({
					size: size,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const encoder = device.createCommandEncoder();
				encoder.copyBufferToBuffer(srcBuffer, 0, staging, 0, size);
				device.queue.submit([encoder.finish()]);

				await staging.mapAsync(GPUMapMode.READ);
				const result = new Float32Array(staging.getMappedRange().slice(0));
				staging.unmap();
				return result;
			}

			async function forward() {
				const device = await init();

				const w1 = new Float32Array(await (await fetch('weights/w1.bin')).arrayBuffer());
				const w2 = new Float32Array(await (await fetch('weights/w2.bin')).arrayBuffer());

				const b1 = new Float32Array(await (await fetch('weights/b1.bin')).arrayBuffer());
				const b2 = new Float32Array(await (await fetch('weights/b2.bin')).arrayBuffer());

				const allImages = new Float32Array(await (await fetch('weights/test_images.bin')).arrayBuffer());
				const testImage = allImages.slice(0, 784);

				const input = createBuffer(device, testImage, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
				const W1 = createBuffer(device, new Float32Array(w1), GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST)
                const bias1 = createBuffer(device, new Float32Array(b1),
                    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
                const W2 = createBuffer(device, new Float32Array(w2), GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
                const bias2 = createBuffer(device, new Float32Array(b2),
                    GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);

                const hidden = device.createBuffer({
                    size: 128 * 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: false
                });
                const output = device.createBuffer({
                    size: 10 * 4,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: false
                });

                const dims1 = device.createBuffer({
                    size: 4 * 4, // (M, N, K) - minimum binding size for uniform buffers must be a multiple of 16.
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: false
                })
                device.queue.writeBuffer(dims1, 0, new Uint32Array([1,128,784]));

                const dims2 = device.createBuffer({
                    size: 4 * 4, // (M, N, K) - minimum binding size for uniform buffers must be a multiple of 16.
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    mappedAtCreation: false
                })
                device.queue.writeBuffer(dims2, 0, new Uint32Array([1,10,128]));

                const SOFT_MAX_SHADER =`
					@group(0) @binding(0) var<storage, read_write> data : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						var max_val: f32 = data[id.x];
						var sum: f32 = 0.0;

						for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
							max_val = max(max_val, data[i]);
						}

						for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
							data[i] = exp(data[i] - max_val);
							sum += data[i];
						}

						for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
							data[i] = data[i] / sum;
						}
					}
				`;

                const RELU_SHADER =`
					@group(0) @binding(0) var<storage, read_write> data : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						data[id.x] = max(data[id.x], 0.0);
					}
				`

                const MAT_MUL_SHADER = `
					struct Dimensions { M: u32, N: u32, K: u32 }
					@group(0) @binding(0) var<uniform> dims : Dimensions;
					@group(0) @binding(1) var<storage, read> input_a : array<f32>;
					@group(0) @binding(2) var<storage, read> input_b : array<f32>;
					@group(0) @binding(3) var<storage, read> bias : array<f32>;
					@group(0) @binding(4) var<storage, read_write> output : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						var sum: f32 = 0.0;
						var col: u32 = id.x;
						var row: u32 = id.y;
						for (var i: u32 = 0u; i < dims.K; i = i + 1u) {
							sum += input_a[row * dims.K + i] * input_b[i * dims.N + col];
						}
						output[row * dims.N + col] = sum + bias[col];
					}
				`;

                const matmulPipeline = createPipeline(device, MAT_MUL_SHADER);
                const reluPipeline = createPipeline(device, RELU_SHADER);
                const softMaxPipeline = createPipeline(device, SOFT_MAX_SHADER)

                const matmulBindGroup = device.createBindGroup({
                    layout: matmulPipeline.getBindGroupLayout(0),
                    entries: [
                        {
                            binding: 0,
                            resource: {buffer: dims1}
                        },
                        {
                            binding: 1,
                            resource: {buffer: input}
                        },
                        {
                            binding: 2,
                            resource: {buffer: W1}
                        },
                        {
                            binding: 3,
                            resource: {buffer: bias1}
                        },
                        {
                            binding: 4,
                            resource: {buffer: hidden}
                        }
                    ]
                });

                const reluBindGroup = device.createBindGroup({
            		layout: reluPipeline.getBindGroupLayout(0),
                    entries: [
                        {
                            binding: 0,
                            resource: { buffer: hidden }
                        }
                    ]
                });

                const matmul2BindGroup = device.createBindGroup({
                      layout: matmulPipeline.getBindGroupLayout(0),
                      entries: [
                          { binding: 0, resource: { buffer: dims2 } },
                          { binding: 1, resource: { buffer: hidden } },
                          { binding: 2, resource: { buffer: W2 } },
                          { binding: 3, resource: { buffer: bias2 } },
                          { binding: 4, resource: { buffer: output } },
                      ]
                  });

                const softmaxBindGroup = device.createBindGroup({
                    layout: softMaxPipeline.getBindGroupLayout(0),
                    entries: [
                        { binding: 0, resource: { buffer: output } }
                    ]
                });

                const encoder = device.createCommandEncoder();

                const p1 = encoder.beginComputePass();
                p1.setPipeline(matmulPipeline);
                p1.setBindGroup(0, matmulBindGroup);
                p1.dispatchWorkgroups(128, 1);
                p1.end();

                const p2 = encoder.beginComputePass();
                p2.setPipeline(reluPipeline);
                p2.setBindGroup(0, reluBindGroup);
                p2.dispatchWorkgroups(128);
                p2.end();

                const p3 = encoder.beginComputePass();
                p3.setPipeline(matmulPipeline);
                p3.setBindGroup(0, matmul2BindGroup);
                p3.dispatchWorkgroups(10, 1);
                p3.end();

                const p4 = encoder.beginComputePass();
                p4.setPipeline(softMaxPipeline);
                p4.setBindGroup(0, softmaxBindGroup);
                p4.dispatchWorkgroups(1);
                p4.end();

                device.queue.submit([encoder.finish()]);
                const result = await readBackBuffer(device, output, 10 * 4);
                console.log("Prediction", result);
			}

			async function softmax() {
				const device = await init();
				const elements = [2.0, 1.0, 0.1];

				const input = device.createBuffer({
					size: elements.length * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});
				device.queue.writeBuffer(input, 0, new Float32Array(elements));

				const shader =`
					@group(0) @binding(0) var<storage, read_write> data : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						var max_val: f32 = data[id.x];
						var sum: f32 = 0.0;

						for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
							max_val = max(max_val, data[i]);
						}

						for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
							data[i] = exp(data[i] - max_val);
							sum += data[i];
						}

						for (var i: u32 = 0; i < arrayLength(&data); i = i + 1) {
							data[i] = data[i] / sum;
						}
					}
				`;

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: {buffer: input}
						},
					]
				});

				const stagingBuffer = device.createBuffer({
					size: elements.length * 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(1);
				pass.end();

				encoder.copyBufferToBuffer(input, 0, stagingBuffer, 0, elements.length * 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const output = new Float32Array(stagingBuffer.getMappedRange());
				console.log(output);
				stagingBuffer.unmap();
			}

			async function relu() {
				const device = await init();
				const elements = [-1.0, 2.0, -3.0, 4.0, -0.5, 0.0];

				const input = device.createBuffer({
					size: elements.length * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});
				device.queue.writeBuffer(input, 0, new Float32Array(elements));

				const shader =`
					@group(0) @binding(0) var<storage, read_write> data : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						data[id.x] = max(data[id.x], 0.0);
					}
				`

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: {buffer: input}
						},
					]
				});

				const stagingBuffer = device.createBuffer({
					size: elements.length * 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(elements.length);
				pass.end();

				encoder.copyBufferToBuffer(input, 0, stagingBuffer, 0, elements.length * 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const output = new Float32Array(stagingBuffer.getMappedRange());
				console.log(output);
				stagingBuffer.unmap();
			}

			async function matmul() {
				const M = 2;
				const K = 3;
				const N = 2;

				const device = await init();

				const matrixA = device.createBuffer({
					size: M * K * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const matrixB = device.createBuffer({
					size: N * K * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const result = device.createBuffer({
					size: M * N * 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});

				const dimensions = device.createBuffer({
					size: 4 * 4, // (M, N, K) - minimum binding size for uniform buffers must be a multiple of 16.
					usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})
				const shader = `
					struct Dimensions { M: u32, N: u32, K: u32 }
					@group(0) @binding(0) var<uniform> dims : Dimensions;
					@group(0) @binding(1) var<storage, read> input_a : array<f32>;
					@group(0) @binding(2) var<storage, read> input_b : array<f32>;
					@group(0) @binding(3) var<storage, read_write> output : array<f32>;
					@compute @workgroup_size(1)
					fn main(@builtin(global_invocation_id) id : vec3<u32>) {
						var sum: f32 = 0.0;
						var col: u32 = id.x;
						var row: u32 = id.y;
						for (var i: u32 = 0u; i < dims.K; i = i + 1u) {
							sum += input_a[row * dims.K + i] * input_b[i * dims.N + col];
						}
						output[row * dims.N + col] = sum;
					}
				`;

				device.queue.writeBuffer(matrixA, 0, new Float32Array([1,2,3,4,5,6]));
				device.queue.writeBuffer(matrixB, 0, new Float32Array([7,8,9,10,11,12]));
				device.queue.writeBuffer(dimensions, 0, new Uint32Array([2,2,3]));

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: {buffer: dimensions}
						},
						{
							binding: 1,
							resource: { buffer: matrixA }
						},
						{
							binding: 2,
							resource: { buffer: matrixB }
						},
						{
							binding: 3,
							resource: { buffer: result }
						}
					]
				});

				const stagingBuffer = device.createBuffer({
					size: M * N * 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(N, M);
				pass.end();

				encoder.copyBufferToBuffer(result, 0, stagingBuffer, 0, M * N * 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const output = new Float32Array(stagingBuffer.getMappedRange());
				console.log(output);
				stagingBuffer.unmap();
			}

			async function sum() {
				const device = await init();
				const shader = `
					@group(0) @binding(0) var<storage, read> input_a : array<f32>;
					@group(0) @binding(1) var<storage, read> input_b : array<f32>;
					@group(0) @binding(2) var<storage, read_write> output : array<f32>;
					@compute @workgroup_size(1)
					fn main() {
						output[0] = input_a[0] + input_b[0];
					}
				`;

				const bufferA = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const bufferB = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const output = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});

				device.queue.writeBuffer(bufferA, 0, new Float32Array([3.0]));
			    device.queue.writeBuffer(bufferB, 0, new Float32Array([4.0]));

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: { buffer: bufferA }
						},
						{
							binding: 1,
							resource: { buffer: bufferB }
						},
						{
							binding: 2,
							resource: { buffer: output }
						}
					]
				});

				const stagingBuffer = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				})

				const encoder = device.createCommandEncoder();

				const pass = encoder.beginComputePass();
				pass.setPipeline(pipeline);
				pass.setBindGroup(0, bindGroup);
				pass.dispatchWorkgroups(1);
				pass.end();

				encoder.copyBufferToBuffer(output, 0, stagingBuffer, 0, 4);

				device.queue.submit([encoder.finish()]);

				await stagingBuffer.mapAsync(GPUMapMode.READ);
				const result = new Float32Array(stagingBuffer.getMappedRange());
				console.log(result);
				stagingBuffer.unmap();
			}

			forward();
		</script>
	</body>
</html>
