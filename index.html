<html>
	<head>
	</head>
	<body>
		<script type="module">
			async function init() {
				const adapter = await navigator.gpu.requestAdapter();
				if (!adapter) {
					console.log("Error, webgpu is not supported");
					return;
				}

				const device = await adapter.requestDevice();
				console.log("Got a device", device);

				const shader = `
					@group(0) @binding(0) var<storage, read> input_a : array<f32>;
					@group(0) @binding(1) var<storage, read> input_b : array<f32>;
					@group(0) @binding(2) var<storage, read_write> output : array<f32>;
					@compute @workgroup_size(1)
					fn main() {
						output[0] = input_a[0] + input_b[0];
					}

				`;

				const bufferA = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const bufferB = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
					mappedAtCreation: false
				});

				const output = device.createBuffer({
					size: 4,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
					mappedAtCreation: false
				});

				device.queue.writeBuffer(bufferA, 0, new Float32Array([3.0]));
			    device.queue.writeBuffer(bufferB, 0, new Float32Array([4.0]));

				const shaderModule = device.createShaderModule({ code: shader });
				const pipeline = device.createComputePipeline({
					layout: 'auto',
					compute: {
						module: shaderModule,
						entryPoint: 'main'
					}
				});
				const bindGroup = device.createBindGroup({
					layout: pipeline.getBindGroupLayout(0),
					entries: [
						{
							binding: 0,
							resource: { buffer: bufferA }
						},
						{
							binding: 1,
							resource: { buffer: bufferB }
						},
						{
							binding: 2,
							resource: { buffer: output }
						}
					]
				});

			}
			init();
		</script>
	</body>
</html>
